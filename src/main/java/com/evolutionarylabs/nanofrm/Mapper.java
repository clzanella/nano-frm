package com.evolutionarylabs.nanofrm;

import com.evolutionarylabs.nanofrm.util.Tuple;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.*;
import java.util.function.Function;

/**
 * Created by cleberzanella on 11/04/17.
 */
public abstract class Mapper {

    private List<ClassMap> classes = new ArrayList<>();

    private Map<Class, ClassMap> components = new HashMap<>();
    private Map<Class, String> javaToSqlTypeMap = new HashMap<>();

    {
        javaToSqlTypeMap.put(int.class, "INTEGER");
        javaToSqlTypeMap.put(Integer.class, "INTEGER");
        javaToSqlTypeMap.put(boolean.class, "INTEGER");
        javaToSqlTypeMap.put(Boolean.class, "INTEGER");
        javaToSqlTypeMap.put(double.class, "DECIMAL");
        javaToSqlTypeMap.put(Double.class, "DECIMAL");
        javaToSqlTypeMap.put(Date.class, "DATETIME(3)");
        javaToSqlTypeMap.put(String.class, "VARCHAR(255)");
    }

    public abstract void mappings();

    protected void add(ClassMap<?> classMap){
        classes.add(classMap);
    }

    protected void component(ClassMap<?> classMap){
        components.put(classMap.clazz, classMap);
    }

    public void load(){

        mappings();

        // load fields
        classes.stream().forEach( m -> m.map());
        components.values().stream().forEach( m -> m.map());

        // sort by dependencies( TODO needs a topological sort)
        Collections.sort(classes, (c1, c2) -> {
            return classDependsOf(c1, c2) ? 1 : -1;
        });

    }

    public String generateDDL(){

        StringBuilder sb = new StringBuilder();

        for(ClassMap map : classes){
            sb.append(generateCreateStatement(map, classes, components, javaToSqlTypeMap));
            sb.append('\n');
        }

        return sb.toString();
    }

    private static String generateCreateStatement(ClassMap map, List<ClassMap> allMaps, Map<Class, ClassMap> components, Map<Class, String> dataTypes){

        StringBuffer sb = new StringBuffer("CREATE TABLE ");

        FieldDefinition pkField = null;
        List<FieldDefinition> fksDefs = new ArrayList<>();
        List<ClassMap> componentss = new ArrayList<>();

        String tableName = map.clazz.getSimpleName();
        sb.append(tableName).append(" (");
        for(Object fieldDef : map.fields){

            FieldDefinition fieldDefinition = (FieldDefinition) fieldDef;

            if(components.containsKey(fieldDefinition.fieldType)){
                componentss.add(components.get(fieldDefinition.fieldType));
                continue;
            }

            sb.append("\n\t").append(fieldDefinition.fieldName).append(" ").append(dataTypes.get(fieldDefinition.fieldType));

            if(fieldDefinition.autoGenerated){
                sb.append(" AUTO_INCREMENT ");
            }

            sb.append(",");

            if(fieldDefinition.primaryKey){
                pkField = fieldDefinition;
            }

            if(fieldDefinition.referencedClass != null){
                fksDefs.add(fieldDefinition);
            }
        }

        for(ClassMap component : componentss){

            for(Object compFieldDef : component.getFields()){
                FieldDefinition compFieldDefinition = (FieldDefinition) compFieldDef;

                sb.append("\n\t").append(compFieldDefinition.fieldName).append(" ").append(dataTypes.get(compFieldDefinition.fieldType)).append(",");
            }
        }

        sb.append("\n\t").append("PRIMARY KEY (").append(pkField.fieldName).append(")");

        for (FieldDefinition fk : fksDefs){
            sb.append(",\n\tCONSTRAINT ").append(tableName).append("_fk_").append(fk.fieldName)
                    .append(" FOREIGN KEY (").append(fk.fieldName).append(") REFERENCES ").append(fk.referencedClass.getSimpleName())
                    .append("(").append(fk.referencedField).append(")");
        }

        sb.append("\n);");


        return sb.toString();
    }

    private static boolean classDependsOf(ClassMap<?> clazz, ClassMap<?> dependantCandidate){
        for(FieldDefinition fieldDef : clazz.getFields()){
            if(dependantCandidate.clazz.equals(fieldDef.referencedClass)){
                return true;
            }
        }

        return false;
    }

    public static abstract class ClassM<T> {}

    public static abstract class ClassMap<T> extends ClassM<T> {

        private Type type;
        private Class<? super T> clazz;
        private List<FieldDefinition<?>> fields = new ArrayList<>();

        public ClassMap(Class<T> clazz) {

            if(clazz == null){

                this.clazz = ((Class) ((ParameterizedType) getClass()
                        .getGenericSuperclass()).getActualTypeArguments()[0]);

                if(this.clazz == null){
                    throw new IllegalArgumentException();
                }

            }

            this.clazz = clazz;
        }

        public abstract void map();

        public <P> FieldDefinition<P> field(Function<T, P> getter){

            Tuple<String, Class<?>> t = getProperty(clazz, getter);

            FieldDefinition<P> fieldDefinition = new FieldDefinition<P>((Class<P>) t.getItem2(), t.getItem1());
            fields.add(fieldDefinition);

            return fieldDefinition;
        }

        public <P> void component(Function<T, P> getter){
            field(getter);
        }

        protected static Tuple<String, Class<?>> getProperty(Class<?> clazz, Function getter){

            final String[] methodName = new String[1];
            final Class[] methodReturnType = new Class[1];

            Object proxy = DynamicProxy.proxy(clazz, new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    methodName[0] = method.getName();
                    methodReturnType[0] = method.getReturnType();

                    if(method.getReturnType().isPrimitive()){
                        return PrimitiveDefaults.getDefaultValue(method.getReturnType());
                    }

                    return null;
                }
            }, DynamicProxy.BYTE_BUDDY_FACTORY);

            getter.apply(proxy);

            String propName = null;

            if(methodName[0].startsWith("get")){
                propName = methodName[0].substring(3);
            } else

            if(methodName[0].startsWith("is")){
                propName = methodName[0].substring(2);
            }

            propName = propName.substring(0, 1).toLowerCase() + propName.substring(1);

            return Tuple.create(propName, methodReturnType[0]);
        }

        public Class<? super T> getClazz() {
            return clazz;
        }

        public List<FieldDefinition<?>> getFields() {
            return fields;
        }
    }

    public static class FieldDefinition<FT> {

        public boolean primaryKey, autoGenerated;
        public Class<FT> fieldType;
        public String fieldName;

        public Class<?> referencedClass;
        public String referencedField;

        public FieldDefinition(Class<FT> fieldType, String fieldName) {
            this.fieldType = fieldType;
            this.fieldName = fieldName;
        }

        public FieldDefinition primaryKey(){
            primaryKey = true;
            return this;
        }

        public FieldDefinition autoGenerated(){
            autoGenerated = true;
            return this;
        }

        public <TR> ReferenceDefinition<TR> reference(Class<TR> classReference){
            return new ReferenceDefinition<TR>(classReference, this);
        }

    }

    public static class ReferenceDefinition<T> {

        private Class<T> clazz;
        private FieldDefinition fieldDefinition;

        public ReferenceDefinition(Class<T> clazz, FieldDefinition fieldDefinition) {
            this.clazz = clazz;
            this.fieldDefinition = fieldDefinition;
        }

        public <P> void on(Function<T, P> getter){

            fieldDefinition.referencedClass = clazz;

            Tuple<String, Class<?>> t =ClassMap.getProperty(clazz, getter);
            fieldDefinition.referencedField = t.getItem1();
        }

    }

    public static class PrimitiveDefaults {
        // These gets initialized to their default values
        private static boolean DEFAULT_BOOLEAN;
        private static byte DEFAULT_BYTE;
        private static short DEFAULT_SHORT;
        private static int DEFAULT_INT;
        private static long DEFAULT_LONG;
        private static float DEFAULT_FLOAT;
        private static double DEFAULT_DOUBLE;

        public static Object getDefaultValue(Class clazz) {
            if (clazz.equals(boolean.class)) {
                return DEFAULT_BOOLEAN;
            } else if (clazz.equals(byte.class)) {
                return DEFAULT_BYTE;
            } else if (clazz.equals(short.class)) {
                return DEFAULT_SHORT;
            } else if (clazz.equals(int.class)) {
                return DEFAULT_INT;
            } else if (clazz.equals(long.class)) {
                return DEFAULT_LONG;
            } else if (clazz.equals(float.class)) {
                return DEFAULT_FLOAT;
            } else if (clazz.equals(double.class)) {
                return DEFAULT_DOUBLE;
            } else {
                throw new IllegalArgumentException(
                        "Class type " + clazz + " not supported");
            }
        }
    }
}
